---
title: 'Linking stormwater control performance to stream ecosystem outcomes: incorporating performance metrics into effective imperviousness'
subtitle: 'Supplementary material S5'
author: 'Christopher J. Walsh, Matthew J. Burns, Tim D. Fletcher, Darren G. Bos, Peter Poelsma, Joshphar Kunapo and Sam J. Imberger'
date: 'School of Ecosystem and Forest Sciences, The University of Melbourne, 500 Yarra Boulevard, Burnley Victoria 3121, Australia '
output: 
  word_document:
    reference_docx: officedown_template.docx
csl: water-resources-research.csl
bibliography: references.bib
---
```{r  load_data, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, dev = "pdf", message=FALSE) #,dpi = 200 
requiredPackages <- c("rstan","loo","coda","sjPlot")
lapply(requiredPackages, require, character.only = TRUE)
rstan_options(auto_write = TRUE)
options(mc.cores = 4)
source("load_ld_scms_tables.R")
fig_no <- 11 + 1  #Fig. S11 last figure in S4
current.seed <- 787603905 #
set.seed(current.seed)  
#to get a consistent result: perhaps 1 in 2 seeds result in lmer models with t (random or fixed) being singular
```

### S5. Statistical model for assessing stream responses to stormwater control measures

Here, we describe a general statistic model for assessing in-stream response to catchment-scale stormwater control in urbanized catchments using a Before-After-Reference-Control-Impact experimental design, such as described in this paper, where the after period is characterised by a protracted period of increased stormwater control (the 'impact'), and the degree of stormwater control varies widely among the 'impact' sites.  

We simulated contrasting response data to illustrate the model's ability to detect change in variables with differing responses to stormwater control. We used a simplified version of our study's data. To remove the complication of L4 and D8 being downstream of other sites (requiring introduction of a spatial autocorrelation term), we constructed a data set of predictor variables for the 9 other sites, which are independent of each other. 

The simulated data set was populated with four samples per year from 2001 to 2019, from each of the 9 sites, and each date was attributed the observed values of *EI~S1* and $\Delta$*EI~S~*.

```{r prepare_sim_set, fig.width = 7, fig.height = 3}
dates <- seq.Date(from = as.Date("2001-02-01"),
                  to = as.Date("2019-11-01"), 
                  by = "3 months")
t <- 1:length(dates)
sitecodes <- siteMap11$sitecode[!siteMap11$sitecode %in% c("LIS0004","DBS0008")]

ei_ts$lei <- log10(ei_ts$ei*100 + 0.1)
ei_ts$lei_s <- ei_ts$lei_s0 <- ei_ts$lei
exp_cats <- unique(ei_ts_all$sitecode)
for(i in 1:length(exp_cats)){
  ei_ts$lei_s[ei_ts$sitecode == exp_cats[i]] <- log10(ei_ts_all$eb[ei_ts_all$sitecode == exp_cats[i]]*100 + 0.1)
  ei_ts$lei_s0[ei_ts$sitecode == exp_cats[i]] <- log10(ei_ts_all$s[ei_ts_all$sitecode == exp_cats[i]]*100 + 0.1)
}
ei_ts$del_ei_s <-  ei_ts$lei_s - ei_ts$lei

sim_set <- data.frame(site = rep(sitecodes, each = length(t)),
                      date = rep(dates, length(sitecodes)),
                      t = rep(t, length(sitecodes)),
                      lei_s1 = NA, del_ei_s = NA)

for(i in 1:length(sitecodes)){
  sim_set$lei_s1[sim_set$site == sitecodes[i]] <- 
    ei_ts$lei[ei_ts$sitecode == sitecodes[i] & ei_ts$date %in% sim_set$date]
  sim_set$del_ei_s[sim_set$site == sitecodes[i]] <- 
    ei_ts$del_ei_s[ei_ts$sitecode == sitecodes[i] & ei_ts$date %in% sim_set$date]
}

layout(matrix(1:3,1,3,byrow=TRUE),widths = c(10,10,2))
plot(jitter(sim_set$t, factor = 2), jitter(sim_set$del_ei_s, factor = 4), 
     col = RColorBrewer::brewer.pal(9,"Set1")[match(sim_set$site, sitecodes)],
     ylab = expression(~Delta~EI[S]), xlab = "time (t)", las = 1)
title(main = "A.", adj = 0)
plot(jitter(sim_set$t, factor = 2), jitter(sim_set$lei_s1, factor = 4), 
     col = RColorBrewer::brewer.pal(9,"Set1")[match(sim_set$site, sitecodes)],
     ylab = expression(log[10](EI[S1] + 0.1)), xlab = "Time (t)", las = 1)
title(main = "B.", adj = 0)
par(mar = c(0,0,0,0))
plot.new()
legend("center",pch = 1, col = RColorBrewer::brewer.pal(9,"Set1"), legend = sitecodes, 
       title = "Site", cex = 1)
```
Fig.S`r fig_no`. Distributions of A. $\Delta$*EI~S~* and B. log(*EI~S1*) as a function of t, the 80 sampling dates in the simulated dataset.  _(I need to confirm the non-zero $\Delta$*EI~S~* values in the before period)_.  
The simulated response variables â€”-- y and y1 --- were hypothetical versions of log(FRP). Individual samples of y and y1 varied among sites as a function of EI as observed for log(median FRP) (Fig. 1A). 

The 20-year study period was characterised by a shift from dry conditions of the milennium drought in the first decade to more average conditions in the second.  It is therefore conceivable that in-stream response variables varied over that time in response to increasingly wet conditions. For instance, increasingly wet catchments could have increased the contribution of ground water to stream flows, and this effect may have been greater in more urban streams.  If there was such a long-term change in stream variables over the study period, there is potential for collinearity between the long-term change, urban growth captured in log(*EI~S1~*) (Fig. S`r fig_no`), and the linear decrease in $\Delta$*EI~S~* as SCMs were progressiveluy installed in the experiment.  To ensure that the model adequately controls for such potential collinearity, we added a linear increase to y and y1 over the study period, which varied between a 0.25% increase per year for Ly (*EI~S1~* = 0) to a 12% increase per year for Br (*EI~S1~* = 21%).

We made no further manipulation of variable y: this variable was thus comparable to FRP observed in the study, but showed no response to $\Delta$*EI~S~*.  In contrast, a further trend was added to y1, so that it varied with $\Delta$*EI~S~* equivalently to *EI~S1* (a slope of 1.1).  Thus a good model of the simulated data should predict that both y and y1 are positively correlated with *EI~S1~* (with a coefficient of ~1.1), while y should be unaffected by $\Delta$*EI~S~* (coefficient of ~0) and y1 should be positively correlated with $\Delta$*EI~S~* (coefficient of ~1.1).  

```{r, fig.width = 7, fig.height = 6}
 lFRP50 <- c(-1.56864E+00, -2.22185E+00, -2.09691E+00, -2.22185E+00, -2.52288E+00, -1.88606E+00, -2.04576E+00, -2.52288E+00, -2.52288E+00, -2.69897E+00, -2.00000E+00, -2.39794E+00, -1.92082E+00, -1.92082E+00) + 3 # + 3 to convert from mg/L to ug/L
 EI <- c(1.95167E-01, 4.26416E-03, 3.62570E-02, 4.19733E-03, 0.00000E+00, 9.52280E-02, 4.63966E-01, 0.00000E+00, 0.00000E+00, 1.16397E-03, 1.03733E-02, 6.65377E-03, 3.82980E-01, 5.47130E-02)
 lei <- log10(EI*100 + 0.1)
mod_frp_ei <- lm(lFRP50 ~ lei)
# 1. vary among sites as a function of EI as observed for log(median FRP)
sim_set$y <- rnorm(dim(sim_set)[1], 
                   summary(mod_frp_ei)$coefficients[1,1],
                   summary(mod_frp_ei)$coefficients[1,2]) +  #distribution of model intercept
             summary(mod_frp_ei)$coefficients[2,1] * sim_set$lei_s1 + #model slope
             rnorm(dim(sim_set)[1], 0,
                   summary(mod_frp_ei)$coefficients[2,2])  #distribution of model slope error
# For the simulation, we allow values of y to fall below the detection limit   

# 2. add a linear increase with time unrelated to the SCM implementation, 
# and make it a greater increase with greater EI...
sim_set$y <- sim_set$y + (sim_set$lei_s1 + 1.05)*sim_set$t/(76*7.5)
# ~0.08% increase per year for LYR - ei = 0% lei_s1 = -1: 10^(0.05*4/(76*7.5))
# ~3.9% increase per year for BRS  - ei = 21.8% lei_s1 = 1.337589: 10^((1.05 + 1.337829)*4/(76*7.5))

# 3. create variable y1 so that its response to del_ei equals its response to ei_s1
sim_set$y1 <- sim_set$y
sim_set$y1 <- sim_set$y + 
              summary(mod_frp_ei)$coefficients[2,1] * sim_set$del_ei_s  #model slope

layout(matrix(c(1:5,3),2,3,byrow=TRUE),widths = c(10,10,2), heights = c(10,10))
plot(sim_set$lei_s1, sim_set$y, 
     col = RColorBrewer::brewer.pal(9,"Set1")[match(sim_set$site, sitecodes)],
     xlab = expression(log[10](EI[S1] + 0.1)), ylab = "y", las = 1)
title(main = "A.", adj = 0)
plot(sim_set$lei_s1, sim_set$y1, 
     col = RColorBrewer::brewer.pal(9,"Set1")[match(sim_set$site, sitecodes)],
     xlab = expression(log[10](EI[S1] + 0.1)), ylab = "y", las = 1)
title(main = "B.", adj = 0)
par(mar = c(0,0,0,0))
plot.new()
legend("center",pch = 1, col = RColorBrewer::brewer.pal(9,"Set1"), legend = sitecodes, 
       title = "Site", cex = 1)
par(mar = c(4,4,1,1))
plot(sim_set$del_ei_s, sim_set$y, 
     col = RColorBrewer::brewer.pal(9,"Set1")[match(sim_set$site, sitecodes)],
     xlab = expression(~Delta~EI[S]), ylab = "y", las = 1)
title(main = "C.", adj = 0)
plot(sim_set$del_ei_s, sim_set$y1, 
     col = RColorBrewer::brewer.pal(9,"Set1")[match(sim_set$site, sitecodes)],
     xlab = expression(~Delta~EI[S]), ylab = "y1", las = 1)
title(main = "D.", adj = 0)

```

----------the following section is for co-author's consideration, not for inclusion in final S5------------

We estimated the posterior distributions of all parameters using a Markov chain Monte Carlo sampler implemented in Stan [@CarpenterEtAl_2017]. We called Stan from R [@RCoreTeam_2018] using the library rstan [@StanDevelopmentTeam_2018]. We specified prior distributions of log-scale effect parameters ($\mu_1$--$\mu_4$)
as diffuse normal distributions (mean 0, standard deviation 10), and of standard deviations ($\sigma_1$--$\sigma_4$) as cauchy distributions (mean 0, scale 2.5).  

We drew inference from `r format(nIter, scientific= FALSE, big.mark = ",")` posterior samples taken from `r nChains` unthinned chains, discarding the first `r format(nWarmup, scientific= FALSE, big.mark = ",")` values of each chain to remove the effects of the randomly generated initial values. We diagnosed convergence by visually inspecting the MCMC chains for adequate mixing and stationarity and using the Gelman-Rubin statistic [with values $\hat R$ < 1.1 indicating convergence; @GelmanEtAl_2004].  We also ensured other standard diagnostic tests for effective sample size, Bayesian Fraction of Missing Information, and saturation of tree depth [@StanDevelopmentTeam_2018b] were satisfied.

The model "woodblocksMT.stan" is reproduced below, with annotations defining variables and parameters, and explaining model components. Below that is the code used to load the data, and run, check, and evaluate the model. The data, and this document in Rmarkdown format, are available at https://osf.io/gmjc5/. Note that a single run of the model took ~6.5 h on a 4-cpu core system at 2.6GHz: full session details are reproduced at the end of the code chunk below.

```{r, fig.width = 7, fig.height = 9}
sim_set$t_scaled <- (sim_set$t - 38.5)/25
mod_fixed_t <- lme4::lmer(y ~ t_scaled + lei_s1 + del_ei_s + (1|site), data = sim_set)
sim_set$t_fac <- factor(t)
mod_random_t <- lme4::lmer(y ~ lei_s1 + del_ei_s + (1|site) + (1|t_fac), data = sim_set)
mod_no_t <- lme4::lmer(y ~ lei_s1 + del_ei_s + (1|site), data = sim_set)

mod_fixed_t_y1 <- lme4::lmer(y1 ~ t_scaled + lei_s1 + del_ei_s + (1|site), data = sim_set)
mod_random_t_y1 <- lme4::lmer(y1 ~ lei_s1 + del_ei_s + (1|site) + (1|t_fac), data = sim_set)
mod_no_t_y1 <- lme4::lmer(y1 ~ lei_s1 + del_ei_s + (1|site), data = sim_set)

mod_fixed_t_varslp <- lme4::lmer(y ~ t + lei_s1 + del_ei_s + (1|site), data = sim_set)

p1 <- sjPlot::plot_model(mod_fixed_t, 
                         title = "A. y, fixed t effect", axis.lim = c(-0.5,5))
p2 <- sjPlot::plot_model(mod_fixed_t_y1, 
                         title = "B. y1, fixed t effect", axis.lim = c(-0.5,5))
p3 <- sjPlot::plot_model(mod_random_t,
                         title = "C. y, random t effect", axis.lim = c(-0.5,5))
p4 <- sjPlot::plot_model(mod_random_t_y1, 
                          title = "D. y1, random t effect", axis.lim = c(-0.5,5))
p5 <- sjPlot::plot_model(mod_no_t, 
                         title = "E. y, no t effect", axis.lim = c(-0.5,5))
p6 <- sjPlot::plot_model(mod_no_t_y1, 
                         title = "F. y1, no t effect", axis.lim = c(-0.5,5))
gridExtra::grid.arrange(p1, p2, p3, p4, p5, p6, nrow = 3)
```

This is an initial comparison of models using three different ways to deal with time for us co-authors to consider...not for publication.  To date, we have used a model most like D and E (without a time effect). These are the least satisfactory models, failing to detect the del_ei_s effect of y1, and inferring a negative effect of y, which should have no del_ei_s effect.  The models with a fixed t effect were the most correct.  The models with a random t effect incorrectly inferred a negative effect of del_ei_s on y, and a smaller del_ei_s effect on y1 than the effect of lei_s1 (they should be the same).

```{r, fig.width = 7, fig.height = 9}
auto_t <- residuals(mod_fixed_t_y1)
for(i in 1:length(sitecodes)){
  sim_set$auto_t[sim_set$site == sitecodes[i]] <- c(NA, auto_t[sim_set$site == sitecodes[i]][-1])
}
mod_fixed_t_auto <- lme4::lmer(y1 ~ t_scaled + lei_s1 + del_ei_s + auto_t + (1|site), data = sim_set)

# auto_t <- residuals(mod_no_t_y1)
# for(i in 1:length(sitecodes)){
#   sim_set$auto_t[sim_set$site == sitecodes[i]] <- c(NA, auto_t[sim_set$site == sitecodes[i]][-1])
# }
# mod_no_t_auto <- lme4::lmer(y1 ~ lei_s1 + del_ei_s + auto_t + (1|site), data = sim_set)

```

Including a fixed t variable makes a temporal autocorrelation term unworkable (at least in this example, and even in the no_t model, which is odd.  Time to move to stan...)

--------------------------- End of section to be excluded from S5 -----------------------------

```{r eval=FALSE}
# Prepare set of values for the model to predict to  #
del_ei_p <- seq(-1,0, length = 15)
#make relevant del_ei_p values equal actual achieved reductions
del_ei_p[7] <- min(sim_set$del_ei_s[sim_set$site == "LSN0001"])
del_ei_p[14] <- min(sim_set$del_ei_s[sim_set$site == "LIS0001"])
del_ei_p[12] <- min(sim_set$del_ei_s[sim_set$site == "LSS0001"])
del_ei_p <- c(del_ei_p[1:11],min(sim_set$del_ei_s[sim_set$site == "DBS0004"]),
              del_ei_p[14:15])
# Make predictions for a reference site, a control site and the 4 experimental 
# sites used in sim_set with ei set at level at end of experiment
ei <- ei_ts$lei[ei_ts$sitecode %in% c("LYR0007","BRS0015","DBS0004",
                                   "LSN0001","LIS0001","LSS0001") & 
                ei_ts$date == max(ei_ts$date)]
new_X <- model.matrix(~ ei_p + del_ei_p + t_scaled_p + site_p,
                      expand.grid(ei_p = ei,
                                  del_ei_p = del_ei_p, 
                                  t_scaled_p = max(sim_set$t_scaled),
                                  site_p = 1:9))
nChains <- 4
nIter <- 9000
nWarmup <- 5000
for (i in 1:2) {  #Full loop takes ~ 40 min to run, including saving the model objects
  if (i == 1) {
    y <- sim_set$y1
  }else{
    y <- sim_set$y
  }
data_list <- list(N = dim(sim_set)[1],
                 N2 = dim(new_X)[1],
                 G = length(sitecodes),
                 y = y,
                 ei = sim_set$lei_s1,
                 del_ei = sim_set$del_ei_s,
                 t_scaled = sim_set$t_scaled,
                 site = match(sim_set$site, sitecodes),
                 ei_p = new_X[,2],
                 del_ei_p = new_X[,3],
                 t_scaled_p = new_X[,4],
                 site_p = new_X[,5])

pars_to_sample <- c("beta_intercept","beta_ei", "beta_del_ei", "beta_t_scaled",
                    "sigma_e","y_pred") 
  #"log_lik","new_y_pred" - can also be saved for model fitting etc.
sim_set_mod <- stan(file = "code/sim_set_vary_t.stan",  
                    data = data_list, chains = nChains, iter = nIter,
                    warmup = nWarmup, save_warmup = FALSE,
                    pars =  pars_to_sample,
                    control = list(adapt_delta = 0.99, max_treedepth = 15),
                    seed = -237947234 ) # ~ 1.5 min to run 
sim_set$non_auto_resids <- sim_set$y1 -  
  as.data.frame(summary(sim_set_mod, pars = "y_pred", probs = c(0.5), use_cache = FALSE)$summary)$`50%`
sim_set$auto_t <- NA
for (j in 1:length(sitecodes)) {
  sim_set$auto_t[sim_set$site == sitecodes[j]][-1] <- 
    sim_set$non_auto_resids[sim_set$site == sitecodes[j]][-sum(sim_set$site == sitecodes[j])]
}
save(sim_set_mod, file = paste0("data/sim_set_mod_",
                                       ifelse(i == 1, "y1", "y"), ".rda"), 
                                       compress = "xz")
rm(sim_set_mod)
data_list <- list(N = dim(sim_set[!is.na(sim_set$auto_t),])[1],
                 N2 = dim(new_X)[1],
                 G = length(sitecodes),
                 y = y[!is.na(sim_set$auto_t)],
                 ei = sim_set$lei_s[!is.na(sim_set$auto_t)],
                 del_ei = sim_set$del_ei_s[!is.na(sim_set$auto_t)],
                 t_scaled = sim_set$t_scaled[!is.na(sim_set$auto_t)],
                 auto_t = sim_set$auto_t[!is.na(sim_set$auto_t)],
                 site = match(sim_set$site[!is.na(sim_set$auto_t)], sitecodes),
                 ei_p = new_X[,2],
                 del_ei_p = new_X[,3],
                 t_scaled_p = new_X[,4],
                 site_p = new_X[,5])

pars_to_sample <- c("beta_intercept","beta_ei", "beta_del_ei", 
                    "beta_auto_t","beta_t_scaled",
                    "sigma_e","new_y_pred","y_pred","log_lik")
sim_set_mod_auto_t <- stan(file = "code/sim_set_vary_t_auto_t.stan",  
                    data = data_list, chains = nChains, iter = nIter,
                    warmup = nWarmup, save_warmup = FALSE,
                    pars =  pars_to_sample,
                    control = list(adapt_delta = 0.99, max_treedepth = 15),
                    seed = -237947234 )  #~5 min to run
save(sim_set_mod_auto_t, file = paste0("data/sim_set_mod_auto_t_",
                                       ifelse(i == 1, "y1", "y"), ".rda"), 
                                       compress = "xz")
if (i == 1) remove(sim_set_mod_auto_t)
}

# #### Model validation (using, in part, functions from stan_utility.R,
# # a utility file available from https://osf.io/8zme2)  ####
# source("code/stan_utility.R")
# mt_summary <- as.data.frame(summary(sim_set_mod)$summary)
# #Rhat for all parameters should be <1.1
# max(mt_summary$Rhat)  # y model 1.007, y1 model 1.007 (y1 without auto_t 1.0147)
# #Bulk effective sample size should be >100 x number of chains (https://mc-stan.org/misc/warnings.html#Bulk_ESS)
# mon <- as.data.frame(monitor(sim_set_mod))
# min(mon$Bulk_ESS)/nChains # y model 243, y1 model 195 (y1 without auto_t 197), for parameter...
# row.names(mon[which.min(mon$Bulk_ESS),]) #lp__
# #Tail effective sample size, same requirement as for Bulk_ESS
# min(mon$Tail_ESS)/nChains # y model 215.5, y1 model 139 (y1 without auto_t 209.3), for parameter...
# row.names(mon)[which.min(mon$Tail_ESS)] #lp__
# #Tree depth should not have been saturated in any iterations
# check_treedepth(sim_set_mod, max_depth = 15)  #y model 0, y1 models 0: should be 0%
# #Energy Bayesian Fraction of Missing Information should be >= 0.2 in all chains
# get_bfmi(sim_set_mod)
# # y model, 0.3491970 0.3631546 0.3994689 0.338864
# # y1 model, 0.3322461 0.4505793 0.3919866 0.2972216 (similar without auto_t)
# #Number of iterations ending in a divergence should be 0
# check_div(sim_set_mod) #  y model 4 (0.025%), y1 model 6 (0.038%), (y1 without auto_t 1 = 0.00625%)
# # traces look otherwise fine, and coefficient distributions seem unchanged
# # for many different runs of the model,
# # so these few divergent transitions are unimportant
# #Visual checks of traceplots and...conducted using shinystan()
# #shinystan::launch_shinystan(sim_set_mod_auto_t)
```
The Stan model without a temporal autocorrelation term (sim_set_vary_t.stan).  

```{r sim_set_vary_t.stan, eval=FALSE, engine="stan"}
data {
int<lower=1> N;     // number of data points
int<lower=1> N2;    // the number of rows in model prediction data set
int<lower=1> G;     // the number of sites (grouping variable)
real y[N];          // response variable
real ei[N];         // EI predictor variable
real del_ei[N];     // delta-EI predictor variable
real t_scaled[N];   // time predictor variable
int<lower=1, upper=G> site[N]; // site predictor variable
real ei_p[N2];       // EI predictor variable for prediction data set
real del_ei_p[N2];   // delta-EI predictor variable for prediction data set
real t_scaled_p[N2]; // time predictor variable for prediction data set
int<lower=1, upper=G> site_p[N2]; // site predictor variable for prediction data set
}

parameters {
real beta_intercept;          // the intercept regression parameter
real beta_ei;                 // the ei regression parameter
real beta_del_ei;             // the del_ei regression parameter
vector[G] beta_t_scaled;           // the del_ei regression parameter
vector[G] gamma;              // the random site parameter
real<lower=0> sigma_e;        // the error sd
real<lower=0> gamma_sigma;    // sd of random site effect
}

 model {  
  sigma_e ~ cauchy(0,2.5);
  gamma_sigma ~ cauchy(0,2.5);
  beta_intercept ~ normal(0,5);
  beta_ei ~ normal(0,5);
  beta_del_ei ~ normal(0,5);

  for(i in 1:G){
   gamma[i] ~ normal(0,gamma_sigma); 
   beta_t_scaled[i] ~ normal(0,5);
  }

  for (i in 1:N)  {
    y[i] ~ normal(beta_intercept + beta_ei * ei[i] + beta_del_ei * del_ei[i] +
                  beta_t_scaled[site[i]] * t_scaled[i] + gamma[site[i]], sigma_e);
}
}

generated quantities {
vector[N2] new_y_pred; // predicted values on evenly spaced major predictor variables
vector[N] y_pred;      // predicted values for evaluating fit
vector[N] log_lik;     // log-likelihood for calculating WAIC and loo
for(i in 1:N2){
   new_y_pred[i] = beta_intercept + beta_ei * ei_p[i] +
                   beta_del_ei * del_ei_p[i] +
                   beta_t_scaled[site_p[i]] * t_scaled_p[i] + gamma[site_p[i]];
   }
for(i in 1:N){
  y_pred[i] = beta_intercept + beta_ei * ei[i] + beta_del_ei * del_ei[i] +
                  beta_t_scaled[site[i]] * t_scaled[i] + gamma[site[i]];
   }
for (i in 1:N) log_lik[i] = normal_lpdf(y[i] | (beta_intercept +
                                                beta_ei * ei[i] +
                                                beta_del_ei * del_ei[i] +
                                                beta_t_scaled[site[i]] * t_scaled[i] +
                                                gamma[site[i]]), sigma_e);
}

```

The Stan model with a temporal autocorrelation term (sim_set_vary_t_auto_t.stan).  

```{r sim_set_vary_t_auto_t.stan, eval=FALSE, engine="stan"}
data {
int<lower=1> N;     // number of data points
int<lower=1> N2;    // the number of rows in model prediction data set
int<lower=1> G;     // the number of sites (grouping variable)
real y[N];          // response variable
real ei[N];         // EI predictor variable
real del_ei[N];     // delta-EI predictor variable
real t_scaled[N];   // time predictor variable
real auto_t[N];     // temporal autocorrelation variable
int<lower=1, upper=G> site[N]; // site predictor variable
real ei_p[N2];       // EI predictor variable for prediction data set
real del_ei_p[N2];   // delta-EI predictor variable for prediction data set
real t_scaled_p[N2]; // time predictor variable for prediction data set
int<lower=1, upper=G> site_p[N2]; // site predictor variable for prediction data set
}

parameters {
real beta_intercept;          // the intercept regression parameter
real beta_ei;                 // the ei regression parameter
real beta_del_ei;             // the del_ei regression parameter
real beta_auto_t;           // the auto_t regression parameter
vector[G] beta_t_scaled;           // the t regression parameter
vector[G] gamma;              // the random site parameter
real<lower=0> sigma_e;        // the error sd
real<lower=0> gamma_sigma;    // sd of random site effect
}

 model {  
  sigma_e ~ cauchy(0,2.5);
  gamma_sigma ~ cauchy(0,2.5);
  beta_intercept ~ normal(0,5);
  beta_ei ~ normal(0,5);
  beta_del_ei ~ normal(0,5);
  beta_auto_t ~ normal(0,5);

  for(i in 1:G){
   gamma[i] ~ normal(0,gamma_sigma); 
   beta_t_scaled[i] ~ normal(0,5);
  }

  for (i in 1:N)  {
    y[i] ~ normal(beta_intercept + beta_ei * ei[i] + beta_del_ei * del_ei[i] + 
                  beta_t_scaled[site[i]] * t_scaled[i] + beta_auto_t * auto_t[i] + gamma[site[i]], sigma_e);
}
}

generated quantities {
vector[N2] new_y_pred; // predicted values on evenly spaced major predictor variables
vector[N] y_pred;      // predicted values for evaluating fit
vector[N] log_lik;     // log-likelihood for calculating WAIC and loo
for(i in 1:N2){
   new_y_pred[i] = beta_intercept + beta_ei * ei_p[i] +
                   beta_del_ei * del_ei_p[i] +
                   beta_t_scaled[site_p[i]] * t_scaled_p[i] + gamma[site_p[i]];
   }
for(i in 1:N){
  y_pred[i] = beta_intercept + beta_ei * ei[i] + beta_del_ei * del_ei[i] +
                  beta_t_scaled[site[i]] * t_scaled[i] + beta_auto_t * auto_t[i] + gamma[site[i]];
   }
for (i in 1:N) log_lik[i] = normal_lpdf(y[i] | (beta_intercept +
                                                beta_ei * ei[i] +
                                                beta_del_ei * del_ei[i] +
                                                beta_t_scaled[site[i]] * t_scaled[i] + 
                                                beta_auto_t * auto_t[i] +
                                                gamma[site[i]]), sigma_e);
}

```

```{r fig.width = 7, fig.height = 5}
for(i in 1:2){
load(paste0("data/sim_set_mod_auto_t_y",ifelse(i == 1, "1",""),".rda"))
assign(paste0("coeffs_y",ifelse(i == 1, "1","")),
       as.data.frame(summary(sim_set_mod_auto_t, 
                             pars = c("beta_intercept","beta_ei","beta_del_ei",
                                      "beta_auto_t","beta_t_scaled"),
                                probs = c(0.025,0.10,0.5,0.9,0.975))$summary))
assign(paste0("new_y_pred_y",ifelse(i == 1, "1","")),
       as.data.frame(summary(sim_set_mod_auto_t, 
                             pars = "new_y_pred", 
                             probs = c(0.025,0.10,0.5,0.9,0.975))$summary))
}
new_X_y <- cbind(new_y_pred_y, new_X)
new_X_y1 <- cbind(new_y_pred_y1, new_X)
new_X_y1$sitecode <- new_X_y$sitecode <- sitecodes[match(new_X_y$site_p,1:9)]

# pdf(file = "images/walsh_etal_foundation_fig6.pdf", width = 7, height = 5.5)
layout(matrix(c(1,3,2,4,5,5),3,2,byrow = TRUE), heights=c(10,11,2),widths = c(10,10))
par(mar = c(2,4,1,1))
plot(c(-0.5,0.5),c(0.5,2.5), type = 'n', ylab = "", xlab = "", axes = 0)
points(coeffs_y$`50%`[2:3], 1:2, pch = 21, bg = "gray", cex = 1.5)
for(i in 1:2){
  lines(c(coeffs_y$`2.5%`[i+1],coeffs_y$`97.5%`[i+1]), c(i,i), lwd = 1.5)
  lines(c(coeffs_y$`10%`[i+1],coeffs_y$`90%`[i+1]), c(i,i), lwd = 3.5)
}
axis(1, at = seq(-1,1,0.2), labels = rep("",11))
axis(2, at = 0:3, labels = c("",expression(EI[S1]),
                             expression(~Delta~EI[S]),""), las = 1)
abline(v = 0, lty = 3)
title(main = "A. y", adj = 0)
par(mar = c(4,4,1,1))
plot(c(-0.5,0.5),c(0.5,2.5), type = 'n', ylab = "", xlab = "", axes = 0)
points(coeffs_y1$`50%`[2:3], 1:2, pch = 21, bg = "gray", cex = 1.5)
for(i in 1:2){
  lines(c(coeffs_y1$`2.5%`[i+1],coeffs_y1$`97.5%`[i+1]), c(i,i), lwd = 1.5)
  lines(c(coeffs_y1$`10%`[i+1],coeffs_y1$`90%`[i+1]), c(i,i), lwd = 3.5)
}
axis(1, at = seq(-1,1,0.2))
axis(2, at = 0:3, labels = c("",expression(EI[S1]),
                             expression(~Delta~EI[S]),""), las = 1)
abline(v = 0, lty = 3)
title(main = "C. y1", adj = 0)
title(xlab = "Coefficient")

# Four 4 experimental catchments, predict for del_ei = 0 (no SCMs),
# del_ei = minimum achieved del_ei achieved in that catchment, and 
# del_ei = -1 (if SCMs were to reduce ei by an order of magnitude)
# and also the reference state LYR0007 at end of study period
experimental_cats <- c("LSN0001","LSS0001","DBS0004","LIS0001")
temp <- new_X_y[0,]
for(i in 1:4){
temp <- rbind(temp,
              new_X_y[new_X_y$sitecode == experimental_cats[i] & 
                    new_X_y$ei_p == -1 &  # i.e. LYR0007 EI
                    new_X_y$del_ei_p == 0,])
temp <- rbind(temp,
              new_X_y[new_X_y$sitecode == experimental_cats[i] & 
                new_X_y$ei_p == ei_ts$lei[ei_ts$sitecode == experimental_cats[i] & 
                                               ei_ts$date == max(ei_ts$date)] & 
                round(new_X_y$del_ei_p,4) %in% round(c(-1,
                      ifelse(i == 2,-0.28571429, min(sim_set$del_ei_s[sim_set$site == experimental_cats[i]])),0),4),])
  }
temp$x <- rep(c(-0.15,-0.075,0.075,0.15),4) + rep(1:4, each = 4)
temp$col <- rep(RColorBrewer::brewer.pal(5, "RdYlGn")[c(5,4,2,1)],4)

par(mar = c(2,4,1,1))
plot(temp$x, temp$`50%`, ylim = c(0.5,1.5), pch = 21, bg = temp$col, 
     cex = 1.25, axes = FALSE, ylab = "y", xlab = "")
for(i in 1:dim(temp)[1]){
lines(rep(temp$x[i],2),c(temp$`2.5%`[i],temp$`97.5%`[i]), col = temp$col[i], lwd = 1.5)
lines(rep(temp$x[i],2),c(temp$`10%`[i],temp$`90%`[i]), col = temp$col[i], lwd = 3.5)
}
points(temp$x, temp$`50%`, pch = 21, bg = temp$col, cex = 1.25)
axis(2, at = seq(-1,2,0.5), las = 1)
axis(1, at = 0:5, labels = rep("",6))
title("B.", adj = 0)

temp <- new_X_y[0,]
for(i in 1:4){
temp <- rbind(temp,
              new_X_y1[new_X_y1$sitecode == experimental_cats[i] & 
                    new_X_y1$ei_p == -1 &  # i.e. LYR0007 EI
                    new_X_y1$del_ei_p == 0,])
temp <- rbind(temp,
              new_X_y1[new_X_y1$sitecode == experimental_cats[i] & 
                new_X_y1$ei_p == ei_ts$lei[ei_ts$sitecode == experimental_cats[i] & 
                                               ei_ts$date == max(ei_ts$date)] & 
                round(new_X_y1$del_ei_p,4) %in% round(c(-1,
                      ifelse(i == 2,-0.28571429, min(sim_set$del_ei_s[sim_set$site == experimental_cats[i]])),0),4),])
  }
temp$x <- rep(c(-0.15,-0.075,0.075,0.15),4) + rep(1:4, each = 4)
temp$col <- rep(RColorBrewer::brewer.pal(5, "RdYlGn")[c(5,4,2,1)],4)

par(mar = c(4,4,1,1))
plot(temp$x, temp$`50%`, ylim = c(0.5,1.5), pch = 21, bg = temp$col, 
     cex = 1.25, axes = FALSE, ylab = "y1", xlab = "")
for(i in 1:dim(temp)[1]){
lines(rep(temp$x[i],2),c(temp$`2.5%`[i],temp$`97.5%`[i]), col = temp$col[i], lwd = 1.5)
lines(rep(temp$x[i],2),c(temp$`10%`[i],temp$`90%`[i]), col = temp$col[i], lwd = 3.5)
}
points(temp$x, temp$`50%`, pch = 21, bg = temp$col, cex = 1.25)
axis(2, at = seq(-1,2,0.5), las = 1)
axis(1, at = 0:5, labels = c("","Ln","Ls","D4","L1",""))
title("D.", adj = 0)
title(xlab = "Experimental site")
par(mar = c(0,0,0,0))
plot.new()
legend("center", c("No SCMs", "Achieved reduction", "EIs reduced by factor of 10", "Reference condition"),
       pch = 21, pt.bg = RColorBrewer::brewer.pal(5, "RdYlGn")[c(1,2,4,5)],
#       lwd = 3.5, col = RColorBrewer::brewer.pal(5, "RdYlGn")[c(5,4,2,1)],
#       title = expression(~Delta~EI[S]), 
       ncol = 4)
# dev.off()
```
